#include <assert.h>
#include <gtk/gtk.h>
#include "gdisplay.hpp"
#include "gmonitor.hpp"
#include "vic_ii.hpp"

namespace __gdisplay__ {

str *const_0, *const_1;

str *__name__;


/**
class TextView
*/

class_ *cl_TextView;


static void create_color(double red, double green, double blue, GdkColor* color) {
	char result[200];
	snprintf(result, 200, "#%04X%04X%04X", (unsigned) (red * 0xFFFF), (unsigned) (green * 0xFFFF), (unsigned) (blue * 0xFFFF));
	bool status = gdk_color_parse(result, color);
	assert(status);
}

static gboolean repaintx(GtkWidget* widget, GdkEventExpose* event, TextView* view) {
	view->repaint();
	return FALSE;
}

void realize(GtkWidget* widget, TextView* view) {
	view->allocate_pixmap();
}

#define WIDTH 366
#define HEIGHT 300

static gboolean handle_key_press(GtkEventBox* widget, GdkEventKey* event, __gmonitor__::Controls* controls) {
g_warning("handle key press %s", gdk_keyval_name(event->keyval &~ 0x20));
    return controls->handle_key_press(new str(gdk_keyval_name(event->keyval &~ 0x20)));
}

static gboolean handle_key_release(GtkEventBox* widget, GdkEventKey* event, __gmonitor__::Controls* controls) {
    return controls->handle_key_release(new str(gdk_keyval_name(event->keyval &~ 0x20)));
}

static GtkEventBox* event_box_new(__gmonitor__::Controls* controls) {
    GtkEventBox* result = GTK_EVENT_BOX(gtk_event_box_new());
    g_object_set(G_OBJECT(result), "can_focus", TRUE, NULL);
    g_signal_connect(G_OBJECT(result), "key-press-event", G_CALLBACK(handle_key_press), controls);
    g_signal_connect(G_OBJECT(result), "key-release-event", G_CALLBACK(handle_key_release), controls);
    return result;
}

void *TextView::__init__(__vic_ii__::VIC_II *VIC, __gmonitor__::Controls *controls) {
    this->VIC = VIC;
    this->first_column = 0;
    this->first_row = 0;
    this->last_column = 0;
    this->last_row = 0;
    this->character_bitmaps_offset = 0; // FIXME correct that
    this->video_offset = 0; // FIXME correct that.
    this->controls = controls;
    this->mode = NORMAL_TEXT;
    this->border_color = 0; // FIXME default
    this->old_VIC_bank = -1;
    this->background_color_0 = 0;
    viewport_column = 0; // FIXME
    viewport_row = 0; // FIXME
    VIC_bank = -1; // FIXME
    characters.clear(); // code -> pixbuf.
    //width = 40;
    //height = 25;
    create_color(0, 0, 0, &colors[0]);
    create_color(1.0, 1.0, 1.0, &colors[1]);
    create_color(115.505637 / 255, 66.5865 / 255, 53.281385 / 255, &colors[2]);
    create_color(123.556863 / 255, 172.47599981 / 255, 185.7811146 / 255.0, &colors[3]);
    create_color(123.039015 / 255.0, 72.130708003 / 255.0, 144.4171376 / 255.0, &colors[4]);
    create_color(100.085985 / 255, 150.9942919966 / 255, 78.70786237 / 255, &colors[5]);
    create_color(63.75 / 255, 50.282779 / 255, 132.75250 / 255, &colors[6]);
    create_color(191.25 / 255, 204.717220846 / 255, 122.24749723 / 255, &colors[7]);
    create_color(123.039015226 / 255, 91.17623437 / 255, 46.832862373 / 255, &colors[8]);
    create_color(78.586358 / 255, 68.63075 / 255, 0.0, &colors[9]);
    create_color(163.318137 / 255, 114.399 / 255, 101.0938853987 / 255, &colors[10]);
    create_color(79.6875 / 255, 79.6875 / 255, 79.6875 / 255, &colors[11]);
    create_color(119.53125 / 255, 119.53125 / 255, 119.53125 / 255, &colors[12]);
    create_color(163.83598477 / 255, 214.74429 / 255, 142.45786 / 255, &colors[13]);
    create_color(119.53125 / 255, 106.064029 / 255, 188.53375 / 255, &colors[14]);
    create_color(159.375 / 255, 159.375 / 255, 159.375 / 255, &colors[15]);
	pixmap = NULL;
	window = GTK_WINDOW(gtk_window_new(GTK_WINDOW_TOPLEVEL));
	g_signal_connect(G_OBJECT(window), "realize", G_CALLBACK(realize), this);
	event_box = event_box_new(controls);
	drawing_area = GTK_DRAWING_AREA(gtk_drawing_area_new());
	g_signal_connect(G_OBJECT(drawing_area), "expose-event", G_CALLBACK(repaintx), this);
	gtk_widget_set_size_request(GTK_WIDGET(drawing_area), WIDTH, HEIGHT); // FIXME make configurable.
	gtk_widget_show(GTK_WIDGET(drawing_area));
	gtk_widget_show(GTK_WIDGET(event_box));
                 //gobject.timeout_add(440, self.repaint_T)
	box = GTK_BOX(gtk_hbox_new(FALSE, 7));
	gtk_container_add(GTK_CONTAINER(event_box), GTK_WIDGET(drawing_area));
	gtk_box_pack_start(box, GTK_WIDGET(event_box), FALSE, FALSE, 0);
	gtk_box_pack_start(box, GTK_WIDGET(controls->get_box()), FALSE, FALSE, 0);
	gtk_widget_show(GTK_WIDGET(box));
	gtk_container_add(GTK_CONTAINER(window), GTK_WIDGET(box));
	gtk_widget_show(GTK_WIDGET(window));

    return NULL;
}

void __init() {
    const_0 = new str("foo");
    const_1 = new str("bar");

    __name__ = new str("gdisplay");

    cl_TextView = new class_("TextView", 51, 51);
}




void TextView::allocate_pixmap() {
	pixmap = gdk_pixmap_new(GTK_WIDGET(window)->window, WIDTH, HEIGHT, -1);
	GdkColormap* colormap = gdk_drawable_get_colormap(GDK_DRAWABLE(pixmap));
	for(int i = 0; i < 16; ++i) {
		GdkColor* color = &colors[i];
		gdk_colormap_alloc_color(colormap, color, FALSE, TRUE);
	}
}

GdkBitmap* TextView::get_pixmap_mask(unsigned char* char_data_1, size_t size, bool B_invert) {
	unsigned char data[8*8*4];
	int data_i = 0;
	for(int row_i = 0; row_i < 8; ++row_i) {
		unsigned char row = *char_data_1++;
		for(int column = 0; column < 8; ++column) {
			if (((row & (1 << (7 - column))) != 0) ^ B_invert) {
				data[data_i++] = 0;
				data[data_i++] = 0;
				data[data_i++] = 0;
				data[data_i++] = 0xFF;
			} else {
				data[data_i++] = 0xFF;
				data[data_i++] = 0xFF;
				data[data_i++] = 0xFF;
				data[data_i++] = 0x00;
			}
		}
	}
	GdkPixbuf* pixbuf = gdk_pixbuf_new_from_data(data, GDK_COLORSPACE_RGB, TRUE, 8, 8, 8, 8*4, NULL, NULL);

	GdkPixmap* pixmap_part;
	GdkBitmap* mask_part;
	gdk_pixbuf_render_pixmap_and_mask(pixbuf, &pixmap_part, &mask_part, 128);
	g_object_unref(pixmap_part);
	g_object_unref(pixbuf);
	return mask_part;
}

void* TextView::unprepare() {
    this->old_VIC_bank = -1;
    return NULL;
}

static void clear_characters(std::vector<GdkBitmap*>& vec) {
	for(std::vector<GdkBitmap*>::reverse_iterator iter = vec.rbegin(); iter != vec.rend(); ++iter) {
		g_object_unref(G_OBJECT(*iter));
	}
	vec.clear();
}

void TextView::prepare_characters() {
	unsigned char character_data[8*256];
	clear_characters(this->characters);
	list<int>* character_data_s = VIC->load_chunk(this->character_bitmaps_offset, 8 * 256); // FIXME
	for(int i = 0; i < 8 * 256; ++i) {
		character_data[i] = character_data_s->__getfast__(i); // FIXME
	}
	std::vector<GdkBitmap*> inverse_characters;
	for(int i = 0; i < 8 * 256; i += 8) {
		// char_data_1 = character_data[i : i + 8]
		this->characters.push_back(get_pixmap_mask(&character_data[i], 8, false));
		inverse_characters.push_back(get_pixmap_mask(&character_data[i], 8, true));
	}
	for(std::vector<GdkBitmap*>::const_iterator iter = inverse_characters.begin(); iter != inverse_characters.end(); ++iter) {
		characters.push_back(*iter);
	}
	inverse_characters.clear();
}

void TextView::repaint_pixmap() {
	GdkWindow* window = pixmap;
	GdkGC* GC;
	gint width, height;
	GdkColor* color;
	GC = gdk_gc_new(window);
	gdk_drawable_get_size(window, &width, &height);
	color = &colors[border_color];
	gdk_gc_set_foreground(GC, color);
	gdk_gc_set_fill(GC, GDK_SOLID);
	gdk_draw_rectangle(window, GC, TRUE, 0, 0, width, height); // TODO only draw border around it.
	gdk_gc_set_foreground(GC, &colors[background_color_0]);
	gdk_draw_rectangle(window, GC, TRUE, first_column, first_row, last_column - first_column + 1, last_row - first_row + 1);

	// FIXME support other modes.
	//if(old_VIC_bank != VIC_bank) {
		old_VIC_bank = VIC_bank;
		prepare_characters();
	//}

	unsigned offset = video_offset;
	unsigned VX = first_column - viewport_column;
	unsigned VY = first_row - viewport_row;
	for(int row = 0; row < 24; ++row) { // FIXME 25
		for(int column = 0; column < 40; ++column) { // FIXME configurable
			unsigned code_color = VIC->VIC_read_memory(offset, 1);
			//g_warning("%X ", code_color);
			unsigned code = code_color & 255;
			unsigned color = code_color >> 8;
			GdkBitmap* pixmap = characters[code];
			/*if (color if code < 128 else self.background_color_0) >= len(self.colors):
					print("WHOOPS, code", code, "color", color)*/
			gdk_gc_set_foreground(GC, &colors[color]); // if code < 128 else self.background_color_0]) # FIXME
			gdk_gc_set_clip_mask(GC, pixmap);
			gdk_gc_set_clip_origin(GC, VX + column * 8, VY + row * 8);
			gdk_draw_rectangle(window, GC, TRUE, VX + column * 8, VY + row * 8, 8, 8);
			++offset;
		}
	}
	g_object_unref(G_OBJECT(GC));
}

void* TextView::repaint() {
	GtkWidget* widget = GTK_WIDGET(drawing_area);
	if(pixmap == NULL)
		return NULL;
	repaint_pixmap();
	GdkGC* GC = gdk_gc_new(widget->window);
	gdk_draw_drawable(GDK_DRAWABLE(widget->window), GC, pixmap, 0, 0, 0, 0, -1, -1);
	g_object_unref(G_OBJECT(GC));
	return NULL;
}

void TextView::set_border_color(unsigned value) {
	assert(value >= 0 && value < 16); // FIXME
	border_color = value;
	// TODO update pixbuf etc.
}

//border_color = property(lambda self: self._border_color, set_border_color)

// TODO unleak colors, characters.

} // module namespace

