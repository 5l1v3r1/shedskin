#include "mmu.hpp"

namespace __mmu__ {

str *const_0, *const_1, *const_2;

str *__name__;
__ss_int minimal_overlay_address;

__ss_bool  default_0;

static inline list<__ss_int> *list_comp_0(str *value);

static inline list<__ss_int> *list_comp_0(str *value) {
    str *c, *__7;
    __ss_int __9;
    __iter<str *> *__8;
    str::for_in_loop __10;
    list<__ss_int> *__ss_result = new list<__ss_int>();

    __ss_result->resize(len(value));
    __ss_int l = value->__len__();
    for(__ss_int i = 0; i < l; ++i) {
        str* v = value->__getitem__(i);
        __ss_result->units[i] = ord(v); /* HERE BE DRAGONS */
    }
#if 0
    FOR_IN_NEW(c,value,7,9,10)
        __ss_result->units[__9] = ord(c);
    END_FOR
#endif

    return __ss_result;
}

/**
class ROM
*/

class_ *cl_ROM;

void *ROM::write_memory(__ss_int address, __ss_int value, __ss_int size) {
    
    throw ((new NotImplementedError(const_0)));
    return NULL;
}

void *ROM::__init__(str *value, __ss_bool B_active) {
    str *__3, *c;
    __ss_int __5;
    __iter<str *> *__4;
    str::for_in_loop __6;

    this->B_active = B_active;

#if 0
    FOR_IN_NEW(c,value,3,5,6)
        print2(0,1, c);
    END_FOR
#endif

    this->memory = list_comp_0(value);
    this->B_can_write = False;
    return NULL;
}

__ss_int ROM::read_memory(__ss_int address, __ss_int size) {
    
    if ((size==1)) {
        return (this->memory)->__getfast__(address);
    }
    return one_big_value((this->memory)->__slice__(3, address, (address+size), 0));
}

__ss_int one_big_value(list<__ss_int> *part) {
    __iter<__ss_int> *__12;
    list<__ss_int> *__11;
    __ss_int __13, c, f, v;
    list<__ss_int>::for_in_loop __14;

    ASSERT(___bool((len(part)<=4)), 0);
    f = 0;
    v = 0;

    FOR_IN_NEW(c,part,11,13,14)
        v = (v|(c<<f));
        f = (f+8);
    END_FOR

    return v;
}

/**
class MMU
*/

class_ *cl_MMU;

ROM *MMU::map_ROM(str *name, __ss_int address, str *value, __ss_bool B_active) {
    ROM *ROM_1;
    dict<str *, tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *> *__41;

    ASSERT(___bool((address>=minimal_overlay_address)), 0);
    ROM_1 = (new ROM(value, B_active));
    this->overlays->__setitem__(name, ((tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *)(new tuple2<tuple2<__ss_int, __ss_int> *, ROM *>(2, (new tuple2<__ss_int, __ss_int>(2, address, (address+len(value)))), ROM_1))));
    return ROM_1;
}

void *MMU::set_overlay_active(str *name, __ss_bool value) {
    __ss_int __45, __46, s;

    print2(0,1, __modct(const_1, 2, name, ___box(value)));
    (this->overlays)->__getitem__(name)->__getsecond__()->B_active = value;
    if ((value==False)) {

        FAST_FOR(s,209,(209+4),1,45,46)
            (__sys__::__ss_stdout)->write(__modct(const_2, 1, ___box(this->read_memory(s, ((__ss_int )(1))))));
        END_FOR

    }
    return NULL;
}

void *MMU::map_IO(str *name, tuple2<__ss_int, __ss_int> *range_1, __memory__::Memory *IO) {
    __ss_bool __42, __43;
    dict<str *, tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *> *__44;

    ASSERT(__OR(___bool((range_1->__getfirst__()>=minimal_overlay_address)), ___bool((range_1->__getsecond__()==2)), 42), 0);
    this->overlays->__setitem__(name, (new tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *>(2, (new tuple2<__ss_int, __ss_int>(2, range_1->__getfirst__(), range_1->__getsecond__())), IO)));
    return NULL;
}

__ss_int MMU::read_memory(__ss_int address, __ss_int size) {
    __ss_int value;

    value = this->xread_memory(address, size);
    return value;
}

__ss_int MMU::read_zero_page(__ss_int address, __ss_int size) {
    
    return this->read_memory(address, size);
}

__ss_int MMU::xread_memory(__ss_int address, __ss_int size) {
    tuple2<__ss_int, __ss_int> *range_1;
    tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *__17;
    __memory__::Memory *controller;
    __iter<tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *> *__19;
    __ss_bool __15, __16, __22, __23, __24;
    list<tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *>::for_in_loop __21;
    list<tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *> *__18;
    __ss_int __20, v;

    if (((address>=minimal_overlay_address) or (address<2))) {

        FOR_IN_NEW(__17,(this->overlays)->values(),18,20,21)
            __17 = __17;
            range_1 = __17->__getfirst__();
            controller = __17->__getsecond__();
            if (((address>=range_1->__getfirst__()) and (address<range_1->__getsecond__()) and controller->B_active)) {
                return controller->read_memory((address-range_1->__getfirst__()), size);
            }
        END_FOR

    }
    if ((size==1)) {
        return (this->memory)->__getfast__(address);
    }
    ASSERT(___bool((size>=0)), 0);
    v = one_big_value((this->memory)->__slice__(3, address, (address+size), 0));
    return v;
}

void *MMU::write_memory(__ss_int address, __ss_int value, __ss_int size) {
    tuple2<__ss_int, __ss_int> *range_1;
    list<tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *>::for_in_loop __31;
    __memory__::Memory *controller;
    __iter<tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *> *__29;
    __ss_bool __25, __26, __32, __33, __34, __35, __36, __37;
    list<__ss_int> *__40;
    tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *__27;
    list<tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *> *__28;
    __ss_int __30, __38, __39, a, i;

    a = address;
    if (((address>=minimal_overlay_address) or (address<2))) {

        FOR_IN_NEW(__27,(this->overlays)->values(),28,30,31)
            __27 = __27;
            range_1 = __27->__getfirst__();
            controller = __27->__getsecond__();
            if (((address>=range_1->__getfirst__()) and (address<range_1->__getsecond__()) and controller->B_active and controller->B_can_write)) {
                ASSERT(__AND(___bool((address!=508)), ___bool((address!=509)), 36), 0);
                return controller->write_memory((address-range_1->__getfirst__()), value, size);
            }
        END_FOR

    }
    ASSERT(1, 0);

    FAST_FOR(i,0,size,1,38,39)
        this->memory->__setitem__((address+i), (value&255));
        value = (value>>8);
    END_FOR

    return 0;
}

void *MMU::__init__() {
    
    this->overlays = (new dict<str *, tuple2<tuple2<__ss_int, __ss_int> *, __memory__::Memory *> *>());
    this->memory = __mul2(65536, (new list<__ss_int>(1, 0)));
    return NULL;
}

void __init() {
    const_0 = new str("cannot write to ROM");
    const_1 = new str("setting overlay %r to %r");
    const_2 = new str("%02X ");

    __name__ = new str("mmu");

    default_0 = True;
    cl_ROM = new class_("ROM", 37, 37);
    minimal_overlay_address = 40960;
    cl_MMU = new class_("MMU", 36, 36);
}

} // module namespace

